//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {

    // Table to store information about procedures
    public static HashMap<String, ClassTable> procedures = new HashMap<String, ClassTable>();
    public static int number_of_lines = 0;        // Represents the number of statements in each procedure
    public static int max_args_in_program = 0;
    int use_or_def = 0;                           // Represents if the TEMP is being used or defined (0 -> used)
    boolean inside_procedure=false;               // Indicates if the parser is parsing inside the procedure or outside
                                                  // Used to decide if label is procedure label or jump label
    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ){
        String label = (String) n.node.accept(this,argu);
        ClassTable ct = (ClassTable) argu;
        ct.label_line.put(label, (Integer) number_of_lines);    // Add corresponding label line mapping
                                                                // This is called only in the case of optional labels in front of statements
         return (R) label;
       }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }


   void create_links(){
    
    for (Map.Entry<String, ClassTable> entry : procedures.entrySet())
    {
      // For each procedure
      ClassTable ct = entry.getValue();
      for(int i=0;i<=ct.end_line-ct.start_line;++i){
          if(ct.temp_line.get(i).next.size() != 0)        // If it is a jump statement
          { 
            // System.out.println("Here");
              String temp = ct.temp_line.get(i).next.get(0);
              temp = Integer.toString(ct.label_line.get(temp));   // Convert it to the corresponding Integer (Line number)
              ct.temp_line.get(i).next.clear();
              ct.temp_line.get(i).next.addFirst(temp);
              // System.out.print("The Line number is: ");
              // System.out.println(temp);
          }

          if(i != ct.end_line-ct.start_line){   // If it is not the last line
            ct.temp_line.get(i).next.addLast(Integer.toString(i+ct.start_line+1));   // Add the next line as an edge
            
            // // Testing
            // System.out.print("Size of the element is: ");
            // System.out.print(ct.temp_line.get(i).next.size());
            // System.out.print(" :: ");
            // System.out.println(ct.temp_line.get(i).next.get(0));
          }


      }
    }    
   }


   void calculate_in_out(){     // Function used to calculate the use and def in each procedure
      for (Map.Entry<String, ClassTable> entry : procedures.entrySet())
      {
        // For each procedure
        ClassTable ct = entry.getValue();
        boolean no_change=false;
        while(!no_change){
          no_change = true;
          for(int i=0;i<=ct.end_line - ct.start_line;++i){
            int initial_in_size = ct.temp_line.get(i).in.size();      // Initial sizes to check if changes have occured
            int initial_out_size = ct.temp_line.get(i).out.size();

            ct.temp_line.get(i).in = new HashSet<String>();
            ct.temp_line.get(i).in.addAll(ct.temp_line.get(i).use);
            Set<String> temp = new HashSet<String>();                 // in = use (union) (out (minus) def)
            temp.addAll(ct.temp_line.get(i).out);
            temp.removeAll(ct.temp_line.get(i).def);
            ct.temp_line.get(i).in.addAll(temp);
            temp = new HashSet<String>();

            ct.temp_line.get(i).out = new HashSet<String>();          // out is union of in of successors
            for(int j=0;j<ct.temp_line.get(i).next.size();++j){
              int next1 = Integer.parseInt(ct.temp_line.get(i).next.get(j));
              ct.temp_line.get(i).out.addAll(ct.temp_line.get(next1-ct.start_line).in);
            }



            if(no_change){
              if((initial_in_size != ct.temp_line.get(i).in.size())||(initial_out_size != ct.temp_line.get(i).out.size())){
                no_change = false;
              }
            }
          }
        }

          // // Debug Statements
          // System.out.println(ct.procedure_name);
          // for(int i=0;i<=ct.end_line - ct.start_line;++i){
            
          //   System.out.print("In is :: "); System.out.println(ct.temp_line.get(i).in);
          //   System.out.print("Out is :: "); System.out.println(ct.temp_line.get(i).out);
          // }
          // System.out.println(ct.temp_register);

          // Calculate the live ranges of all the temporary variables

          for(int i=0;i<=ct.end_line - ct.start_line;++i){
              for(String temp : ct.temp_line.get(i).in){
                 if(ct.temp_ranges_hash.containsKey(temp)){
                    intervals in = ct.temp_ranges_hash.get(temp);
                    int cur = i+ct.start_line;
                    if(cur < in.start_line){
                      in.start_line = cur;
                    }
                    if(cur > in.end_line){
                      in.end_line = cur;
                    }
                 }
                 else{
                    intervals in = new intervals();
                    in.start_line = i+ct.start_line;
                    in.end_line = i+ct.start_line;
                    in.temp_name = temp;
                    ct.temp_ranges_hash.put(temp, in);
                 }
              }            
          }

          for(int i=0;i<=ct.end_line - ct.start_line;++i){
              for(String temp : ct.temp_line.get(i).out){
                 if(ct.temp_ranges_hash.containsKey(temp)){
                    intervals in = ct.temp_ranges_hash.get(temp);
                    int cur = i+ct.start_line;
                    if(cur < in.start_line){
                      in.start_line = cur;
                    }
                    if(cur > in.end_line){
                      in.end_line = cur;
                    }
                 }
                 else{
                    intervals in = new intervals();
                    in.start_line = i+ct.start_line;
                    in.end_line = i+ct.start_line;
                    in.temp_name = temp;
                    ct.temp_ranges_hash.put(temp, in);
                 }
              }            
          }


          // for(int i=0;i<=ct.end_line - ct.start_line;++i){
          //     for(String temp : ct.temp_line.get(i).out){
          //        if(ct.temp_ranges_hash.containsKey(temp)){
          //           intervals in = ct.temp_ranges_hash.get(temp);
          //           int cur = i+ct.start_line;
          //           if(cur < in.start_line){
          //             in.start_line = cur;
          //           }
          //           if(cur > in.end_line){
          //             in.end_line = cur;
          //           }
          //           // in.end_line = i+ct.start_line;                  // Check if you have to add here

          //        }
          //        else{
          //           intervals in = new intervals();
          //           in.start_line = i+ct.start_line;
          //           in.end_line = i+ct.start_line;
          //           in.temp_name = temp;
          //           ct.temp_ranges_hash.put(temp, in);
          //        }
          //     }            
          // }

          for (Map.Entry<String, intervals> entry1 : ct.temp_ranges_hash.entrySet())
          {
              ct.temp_ranges.add(entry1.getValue());
          }

          Collections.sort(ct.temp_ranges);       // Sort with respect to starting line numbers

          // // Debug Statements
          // System.out.println(ct.procedure_name);
          // for(int zz=0;zz<ct.temp_ranges.size();++zz){
          //   System.out.print("TEMP ");
          //   System.out.print(ct.temp_ranges.get(zz).temp_name);
          //   System.out.print("::");
          //   System.out.print(ct.temp_ranges.get(zz).start_line);
          //   System.out.print("::");
          //   System.out.println(ct.temp_ranges.get(zz).end_line);
          // }


        
      }    
   }

   Set<intervals> expire_old_intervals(intervals cur, Set<intervals> live_temp, Queue<String> register_pool, ClassTable ct){
      Set<intervals> old = live_temp;
      live_temp = new HashSet<intervals>();

      // System.out.print("Before::");
      // System.out.println(live_temp.size());
      for(intervals cur_interval : old){
         if(cur_interval.end_line >= cur.start_line){
            live_temp.add(cur_interval);
         }
         else{
            if(!ct.temp_register.get(cur_interval.temp_name).equals("spill")){
                register_pool.add(ct.temp_register.get(cur_interval.temp_name));
            }
         }
      }

      // System.out.print("After::");
      // System.out.println(live_temp.size());

      return live_temp;

   }

   Set<intervals> spill_at_interval(intervals cur, Set<intervals> live_temp, ClassTable ct){
      intervals max_ending_point = cur;
      Set<intervals> old = live_temp;
      live_temp = new HashSet<intervals>();

      for(intervals cur_interval : old){
         if(cur_interval.end_line > max_ending_point.end_line){
            max_ending_point = cur_interval;                      // If the current interval is the last ending interval
         }
      }

      if(max_ending_point == cur){
          ct.temp_register.put(cur.temp_name, "spill");
      }
      else{
          ct.temp_register.put(cur.temp_name, ct.temp_register.get(max_ending_point.temp_name));  // Allocate the register
          // String temp_register1 = ct.temp_register.get(max_ending_point.temp_name);
          // temp_register1 = "spill";
          ct.temp_register.put(max_ending_point.temp_name, "spill");

          Iterator<intervals> iterator = old.iterator();
          while (iterator.hasNext()) {
              intervals element = iterator.next();
              if (element.temp_name.equals(max_ending_point.temp_name)) {
                  continue;
              }
              else{
                live_temp.add(element);
              }
          }

          live_temp.add(cur);     // Add current interval
      }

      return live_temp;
   }

   void create_register_pool(Queue<String> register_pool){
      register_pool.add("t0");
      register_pool.add("t1");
      register_pool.add("t2");
      register_pool.add("t3");
      register_pool.add("t4");
      register_pool.add("t5");
      register_pool.add("t6");
      register_pool.add("t7");
      register_pool.add("t8");
      register_pool.add("t9");
      register_pool.add("s0");
      register_pool.add("s1");
      register_pool.add("s2");
      register_pool.add("s3");
      register_pool.add("s4");
      register_pool.add("s5");
      register_pool.add("s6");
      register_pool.add("s7");
   }

   void linear_scan(){
      // Set<String> register_pool = new HashSet<String>();
      Queue<String> register_pool = new LinkedList<String>();
      for(Map.Entry<String, ClassTable> entry : procedures.entrySet()){
        // register_pool = new HashSet<String>();
        register_pool = new LinkedList<String>();     
        create_register_pool(register_pool);           // Create a new register pool
        ClassTable ct = entry.getValue();
        Set<intervals> live_temp = new HashSet<intervals>();

        for(int i=0;i<ct.temp_ranges.size();++i){       // Read the temp_ranges in sorted order
            live_temp = expire_old_intervals(ct.temp_ranges.get(i), live_temp, register_pool, ct);
            // System.out.print("After Function call::");
            // System.out.println(live_temp.size());

            if((Integer.parseInt(ct.temp_ranges.get(i).temp_name) > 3)&&(ct.num_of_args >= Integer.parseInt(ct.temp_ranges.get(i).temp_name))){
                ct.temp_register.put(ct.temp_ranges.get(i).temp_name, "spill");    // Assign the next register
                continue;
            }

            if(live_temp.size() >= 18){
              // System.out.print("Spilling going to occur :: ");
              ct.did_it_spill=true;
              ct.stack_space++;
                live_temp = spill_at_interval(ct.temp_ranges.get(i), live_temp, ct);
            }
            else{
                // String next_register;
                // Iterator<String> it = register_pool.iterator();
                // next_register = it.next();
                // it.remove();
                String next_register = register_pool.remove();
                
                ct.temp_register.put(ct.temp_ranges.get(i).temp_name, next_register);    // Assign the next register
                live_temp.add(ct.temp_ranges.get(i));     // Add register to live range
            }
        }

        // // Debug Statements
        // System.out.println(ct.procedure_name);
        // System.out.println(ct.temp_register);
      }

   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      ClassTable ct = new ClassTable();        // ClassTable entry for MAIN Procedure
      argu = (A) ct;
      ct.start_line = number_of_lines;         // Start line
      ct.procedure_name = "MAIN";
      ct.num_of_args = 0;           // MAIN class takes 0 arguments
      procedures.put("MAIN", ct);
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      ct.end_line = number_of_lines-1;        // Last line of the procedure
      inside_procedure = true;                // Inside the procedure body
      n.f3.accept(this, argu);
      inside_procedure = false;

      create_links();             // Create links in the graph to complete the CFG (forward referencing)
      calculate_in_out();         // Compute in and out from use and def
      linear_scan();
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      // if(argu == null)
      // {
      //   System.out.println("NULL Here");
      // }
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      String label = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String args = (String) n.f2.accept(this, argu);
      max_args_in_program = Math.max(max_args_in_program, Integer.parseInt(args));
      ClassTable ct = new ClassTable();                            // Add an entry to the HashMap
      ct.procedure_name = label;
      ct.num_of_args = Integer.parseInt(args);          // Store the number as an integer rather than a String
      procedures.put(label, ct);                        // Add the entry to the HashMap
      n.f3.accept(this, argu);

      // Pass the procedure table as an argument
      argu = (A) ct;
      inside_procedure = true;      // Inside the procedure body
      ct.start_line = number_of_lines;         // Start line of procedure                           
      n.f4.accept(this, argu);
      inside_procedure = false;     // Outside the procedure body
      ct.end_line = number_of_lines-1;         // End line of the procedure
      ct.stack_space = ct.stack_space + Math.max(0, ct.num_of_args-4);
      // System.out.print("Stack Space is: ");System.out.println(ct.stack_space);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      ClassTable ct = (ClassTable) argu;    // ClassTable for argument
      ct.temp_line.add(new liveness());
      n.f0.accept(this, argu);
      number_of_lines++;            // Increment the number of statements
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      ClassTable ct = (ClassTable) argu;
      n.f0.accept(this, argu);
      use_or_def = 0;             // Variable being evaluated
      n.f1.accept(this, argu);
      use_or_def = 0;
      String label = (String) n.f2.accept(this, argu);
      ct.temp_line.get(number_of_lines-ct.start_line).next.add(label);   // Create an edge for this basic block to the label block
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      ClassTable ct = (ClassTable) argu;
      n.f0.accept(this, argu);
      String label = (String) n.f1.accept(this, argu);
      ct.temp_line.get(number_of_lines-ct.start_line).next.add(label);   // Create an edge for this basic block to the label block
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 0;             // All the variables have to be evaluated
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      use_or_def = 0;
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 1;
      n.f1.accept(this, argu);      // Have to store the value in this temporary
      use_or_def = 0;
      n.f2.accept(this, argu);
      use_or_def = 0;
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 1;           // Defining the variable
      n.f1.accept(this, argu);
      use_or_def = 0;
      n.f2.accept(this, argu);
      use_or_def = 0;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 0;             // Variable is being used
      n.f1.accept(this, argu);
      use_or_def = 0;
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      ClassTable ct = (ClassTable) argu;
      ct.temp_line.add(new liveness());
      use_or_def = 0;
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      use_or_def = 0;
      number_of_lines++;                // Return expression also considered as a statement
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      use_or_def = 0;           // The variable is being used as arguments
      n.f3.accept(this, argu);
      use_or_def = 0;
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 0;
      n.f1.accept(this, argu);
      use_or_def = 0;
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use_or_def = 0;           // Temp is being used
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      use_or_def = 0;
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp_no = (String) n.f1.accept(this, argu);
      ClassTable ct = (ClassTable) argu;
      // ct.temp_register.put(temp_no, "spill");

      // System.out.println("TEMP "+temp_no);     // Debug Statement
      if(use_or_def == 0)
      {
        ct.temp_line.get(number_of_lines-ct.start_line).use.add(temp_no);     // Add to the correct linkedlist (use or def)
      }
      else
      {
        ct.temp_line.get(number_of_lines-ct.start_line).def.add(temp_no);
      }
      
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      ClassTable ct = (ClassTable) argu;       // Class table for the procedure
      n.f0.accept(this, argu);
      return (R) n.f0.toString();     // Return the integer literal as a string. Parse when it is being used
      // return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) n.f0.toString();     // Return the label
      // return _ret;
   }

}