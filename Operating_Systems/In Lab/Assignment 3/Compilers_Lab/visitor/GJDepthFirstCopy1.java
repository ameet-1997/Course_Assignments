//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirstCopy1<R,A> extends GJDepthFirst<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

    public HashMap<String, ClassTable> all_tables;
    public String typeerror = "Type error";
    public String symbolnotfound = "Symbol not found";


   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

    public void perform_all_checks(){
        check_class_extends();          // Check for class loops and no declaration
        check_function_overriding();    // Check if overriding is happening, then the arguments should match
    }

    // Check if cycles exist in class inheritance and also if class inherits, check if parent exists
    public void check_class_extends() {
       for (HashMap.Entry<String, ClassTable> entry : all_tables.entrySet()) {      // For all entries in the HashMap
        String key = entry.getKey();
        ClassTable table = entry.getValue();

        if(!table.for_checking_cycle)
        {   
            String temp = table.current_name;
            if(table.parent == null)
            {
                continue;
            }

            while(table != null)
            {   
                table.for_checking_cycle = true;
                if(table.parent == null)        // If there is no parent
                {
                    break;
                }
                else
                {
                    if(!all_tables.containsKey(table.parent))       // If parent does not exist
                    {
                        System.out.println(symbolnotfound);
                        System.exit(0);                     
                    }
                    table = all_tables.get(table.parent);
                }

                if(table.current_name.equals(temp))
                {   
                    // System.out.println("In check class extends");
                    System.out.println(typeerror);
                    System.exit(0);             
                }

            }
        }
    }
   }

   public boolean compare_lists(ClassTable a, ClassTable b)
   {
          Iterator<String> itr1=a.arguments.iterator();
          Iterator<String> itr2=b.arguments.iterator();  

          if(a.arguments.size() != b.arguments.size())
          {
            return false;          
          }

          while(itr1.hasNext()&&itr2.hasNext()){
            // if(!check_types(itr1.next(), itr2.next()))
                if(!itr1.next().equals(itr2.next()))
               {
                    return false;
               } 
          }         

          // Check the order of this arguments

          return check_types(b.return_type, a.return_type);     // Second argument is parent table
   }

   // Overloaded function for the previous function
   public boolean compare_lists(LinkedList<String> a, LinkedList<String> b)
   {
          Iterator<String> itr1=a.iterator();
          Iterator<String> itr2=b.iterator();  

          if(a.size() != b.size())
          {
            return false;
          }

          while(itr1.hasNext()&&itr2.hasNext()){  
           // System.out.println(itr1.next()); 
               // if(itr1.next() != itr2.next())
                if(!check_types(itr1.next(), itr2.next()))
               {
                    return false;
               } 
          }         

          // Check the order of this arguments

          return true;
   }

   public void check_function_overriding(){
       for (HashMap.Entry<String, ClassTable> entry : all_tables.entrySet()) {      // For all entries in the HashMap
        String key = entry.getKey();
        ClassTable table = entry.getValue();
        ClassTable table1;

           for (HashMap.Entry<String, ClassTable> entry1 : table.method.entrySet()) {      // For all functions in class
            String func_name = entry1.getKey();
            ClassTable func_table = entry1.getValue();
            table1 = entry.getValue();
            table1 = all_tables.get(table.parent);

            while(table1 != null)
            {
                if(table1.method.containsKey(func_name))
                {
                    if(!compare_lists(table.method.get(func_name), table1.method.get(func_name)))
                    {   
                        // System.out.println("In check function overriding");
                        System.out.println(typeerror);
                        System.exit(0);              
                    }
                }

                table1 = all_tables.get(table1.parent);
            }


        }  

    }    
   }

   ClassTable get_func_table(String type, String func_name)
   {
        ClassTable table = all_tables.get(type);

        while(table != null)
        {
            if(table.method.containsKey(func_name))
            {
                return table.method.get(func_name);
            }

            table = all_tables.get(table.parent);
        }

        return null;
   }


   public String get_id_type(String name, ClassTable table)
   {    
        if((name.equals("int"))||(name.equals("boolean"))||(name.equals("int[]")))
        {
            return name;
        }

        if(all_tables.get(name) != null)        // If it is a class name
        {
            return name;
        }

        if(table.argument_names.contains(name))
        {
            int ind = table.argument_names.indexOf(name);
            return table.arguments.get(ind);
        }

        // while(table.parent != null)
        while(table != null)
        {
            if(table.id.containsKey(name))
            {
                return table.id.get(name);
            }
            table = all_tables.get(table.parent);
        }

        return null;
   }

   public boolean check_types(String type1, String type2)
   {
        if((type1 != null)&&(type1.equals(type2)))          // Check if two types are the same
        {
            return true;
        }

        ClassTable table = all_tables.get(type2);
        while(table != null)                        // If they are not the same, check if right is derived from left
        {
            if(type1.equals(table.current_name))
            {
                return true;
            }
            table = all_tables.get(table.parent);
        }

        return false;
   }

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      // System.out.println("In Goal");
      all_tables = new HashMap<String, ClassTable>((HashMap<String, ClassTable>) argu);   // creates a local copy of table
      perform_all_checks();         // Performs all symbol table checks before second pass

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      // all_tables.get("Fac");
      return _ret;
      // return (R)all_tables;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) {
      R _ret=null;
      HashMap<String, ClassTable> table = new HashMap<String, ClassTable>();
      n.f0.accept(this, argu);
      String main_class = (String) n.f1.accept(this, argu);
      table.put("dummy", all_tables.get(main_class).method.get("main"));
      
      argu = (A) table;                             // Send the required symbol table to the functions
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);      // Return type
      n.f6.accept(this, argu);      // Function name
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);   // Argument names
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String name = (String) n.f1.accept(this, argu);

      HashMap<String, ClassTable> table = new HashMap<String, ClassTable>();
      table.put("dummy", all_tables.get(name));

      argu = (A) table;                             // Send the required symbol table to the functions

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String class_name = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String par_name = (String) n.f3.accept(this, argu);

      if(!all_tables.containsKey(par_name))     // If parent class is not defined
      {
        System.out.println(symbolnotfound);
        System.exit(0);
      }
      else if(par_name.equals(class_name))           // If class name and parent names are the same
      { 
        // System.out.println("In class extends declaration");
        System.out.println(typeerror);
        System.exit(0);
      }

      HashMap<String, ClassTable> table = new HashMap<String, ClassTable>();
      table.put("dummy", all_tables.get(class_name));
      argu = (A) table;                             // Send the required symbol table to the functions

      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String declared_type = (String) n.f1.accept(this, argu);
      String func_name = (String) n.f2.accept(this, argu);
      HashMap<String, ClassTable> temp = (HashMap<String, ClassTable>) argu;
      ClassTable table = temp.get("dummy").method.get(func_name);             

      HashMap<String, ClassTable> table_ = new HashMap<String, ClassTable>();   // Pass the function symbol table
      table_.put("dummy", table);

      argu = (A) table_;

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      String return_type_func = (String) n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);

      if(!check_types(declared_type, return_type_func))
      {
            System.out.println(typeerror);
            System.exit(0);        
      }

      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      return n.f0.accept(this, argu);
      // return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      return (R) "int[]";
      // return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) "boolean";
      // return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) "int";
      // return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;

      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");

      String id_name = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String expr_type = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      String id_type = get_id_type(id_name, table);

      if(id_type == null)           // Symbol not found in any of the symbol tables
      {
        System.out.println(symbolnotfound);
        System.exit(0);        
      }

      if(!(check_types(id_type, expr_type)))   // Symbol is found but does not match
      { 
        // System.out.println("In AssignmentStatement");
        System.out.println(typeerror);
        System.exit(0);
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;

      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");

      String id_name = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String check1 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      String check2 = (String) n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      String id_type = get_id_type(id_name, table);

      if(!(check_types(id_type,"int[]")&&check_types(check1,"int")&&check_types(check2,"int")))
      { 
        // System.out.println("In ArrayAssignmentStatement");
        System.out.println(typeerror);
        System.exit(0);        
      }

      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String check = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      if(!(check_types(check, "boolean")))
      { 
        // System.out.println("In IfthenStatement");
        System.out.println(typeerror);
        System.exit(0);         
      }

      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String check = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      if(!(check_types(check, "boolean")))
      { 
        // System.out.println("In IfthenElseStatement");
        System.out.println(typeerror);
        System.exit(0);         
      }      

      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String check = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      if(!(check_types(check, "boolean")))
      { 
        // System.out.println("In WhileStatement");
        System.out.println(typeerror);
        System.exit(0);         
      }

      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      R _ret=null;

      HashMap<String, ClassTable> table = (HashMap<String, ClassTable>) argu;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      R _ret=null;
      return n.f0.accept(this, argu);       // Return the corresponding expression type
      // return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "boolean")&&(check_types(type2, "boolean"))))
      { 
        // System.out.println("In AndExpression");
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "boolean")&&(check_types(type2, "boolean"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      { 
        // System.out.println("Cupped here");
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) "boolean";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) "boolean";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);

      if(!(check_types(type1, "int")&&(check_types(type2, "int"))))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type1;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      String type1 = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = (String) n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      if(!(check_types(type1, "int[]")&&(check_types(type2,"int"))))
      { 
        // System.out.println("In ArrayLookup");
        System.out.println(typeerror);
        System.exit(0);          
      }

      return (R) type2;
      // return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      String check = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      if(!check_types(check, "int[]"))
      { 
        // System.out.println("In ArrayLength");
        System.out.println(typeerror);
        System.exit(0);          
      }

      return (R) "int";

      // return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      R _ret=null;
      // System.out.println("In Message Send");
      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");

      String type = (String) n.f0.accept(this, argu);
      // System.out.println("The identifier is");
      // System.out.println(type);
      type = get_id_type(type, table);                  // Type of the calling object

      n.f1.accept(this, argu);
      String func_name = (String) n.f2.accept(this, argu);
      ClassTable func_table = get_func_table(type, func_name);

      if((type == null)||(func_table == null))
      {
        System.out.println(symbolnotfound);
        System.exit(0);        
      }

      n.f3.accept(this, argu);

      String arg = (String) n.f4.accept(this, argu);    // All the arguments of the function


      
      if(!compare_lists(func_table.arguments, table.for_checking_arguments))     // Match the arguments of the expression and function
      {     
        System.out.println(typeerror);
        System.exit(0);        
      }
      // Remove the objects in for_checking_arguments
      table.for_checking_arguments.clear();

      // System.out.println("Leaving MessageSend");

      n.f5.accept(this, argu);

      return (R) func_table.return_type;    // Return type of the function
      // return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      R _ret=null;
      String type = (String) n.f0.accept(this, argu);
      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");     // Add arguments to the dummy table
      table.for_checking_arguments.add(type);
      // System.out.println("Fine here");
      n.f1.accept(this, argu);


      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String type = (String) n.f1.accept(this, argu);

      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");
      table.for_checking_arguments.add(type);

      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;

      // If the primary expression name is a class name, then it is returning null

      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");
      String prim_exp = (String) n.f0.accept(this, argu);
      // System.out.println("Before::After");
      // System.out.println(prim_exp);
      prim_exp = get_id_type(prim_exp, table);
      if(prim_exp == null)
      {
            System.out.println(symbolnotfound);
            System.exit(0);          
      }
      // System.out.println(prim_exp);
      return (R) prim_exp;
      // return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) "int";
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) "boolean";
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) "boolean";
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {       // Returns the name of the identifier
        R _ret = null;
        n.f0.accept(this, argu);
      String temp = n.f0.toString();

      _ret = (R) temp;
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret=null;

      ClassTable table = ((HashMap<String, ClassTable>) argu).get("dummy");

      n.f0.accept(this, argu);          // Return the parent of the method(the class)
      return (R) table.parent;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return (R) "int[]";
      // return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String name = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      if(!all_tables.containsKey(name))       // If the identifier does not exist
      {
        System.out.println(symbolnotfound);
        System.exit(0);
      }

      return (R) name;
      // return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String type = (String) n.f1.accept(this, argu);

      if(!(type.equals("boolean")))
      {
        System.out.println(typeerror);
        System.exit(0);
      }

      return (R) type;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String same = (String) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      // System.out.println("In BracketExpression");
      // System.out.println(same);
      return (R) same;
      // return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public R visit(IdentifierList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

}